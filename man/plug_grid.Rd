% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pre-action-grid.R
\name{plug_grid}
\alias{plug_grid}
\alias{drop_grid}
\alias{replace_grid}
\title{Add a grid specification to a tidyflow}
\usage{
plug_grid(x, .f, ..., expand = FALSE)

drop_grid(x)

replace_grid(x, .f, ..., expand = FALSE)
}
\arguments{
\item{x}{A tidyflow}

\item{.f}{A function which will be passed the tuned arguments from the model
and recipe. Must return an object of class \code{param_grid}. See package
\code{\link[dials]{dials}}.}

\item{...}{arguments passed to \code{.f}. The processing of \code{...}
respects the quotation rules from \code{.f}. In other words, if the function
allows variables as strings \strong{and} as names, the user can specify both.
See the example section.}

\item{expand}{A logical stating whether to treat \code{.f} as an expanding
function. This behavior changes how \code{plug_grid} works in important ways.
In particular, \code{.f} should only be \code{`expand.grid`} and any arguments in
\code{...} should be all the tuning parameters defined in the tidyflow to be
expanded. This does not support parameter objects like
\code{\link[dials]{mixture}} but rather the raw values to be expanded
by \code{expand.grid}. For example, instead of \code{penalty = dials::mixture()}
it should be \code{mixture = c(0, 0.5, 1)}. See the example section.}
}
\value{
\code{x}, updated with either a new or removed grid specification.
}
\description{
\itemize{
\item \code{plug_grid()} specifies the type of grid used in the model tuning. It
accepts a function \code{.f} that will be fed the tuning parameters defined
in the model and the recipe. Only functions which return a \code{param_grid}
object will be allowed. See package \code{\link[dials]{dials}} and
the details section. If a model has been fit before adding the grid,
it will need to be refit.
\item \code{drop_grid()} removes the grid specification from the tidyflow. Note
that it keeps other preprocessing steps such as the recipe and model.
\item \code{replace_grid()} first removes the grid, then adds a new grid
specification. Any model that has already been fit based on this
split will need to be refit.
}
}
\details{
The grid specification is an optional step in the tidyflow. You can add
the data, prepare a recipe and fit the model without adding a grid
specification.

The tuning parameters defined in the model and recipe are extracted
and passed to \code{.f}. If \code{expand = TRUE}, the result of \code{.f}
should return be an object of class \code{param_grid}. The functions used
to generate the grid values should come from the \code{\link[dials]{dials}}
package. However, if \code{expand = FALSE}, only \code{expand.grid} is supported in
\code{.f} and each parameter should not be a parameter object (for example
\code{\link[dials]{mixture}}). Rather, they should be the raw values used
to expand, such as \code{mixture = c(0, 0.5, 1)}. For more details see
the description of \code{expand} argument and the example section.

If a tuning parameter in the model/recipe is assigned a name (that is,
\code{tune("new_name")}) and the user is interested in specifying
the tuning values for that parameter using \code{plug_grid} or
\code{replace_grid}, then the parameter name should have the name not
the original name. See the example section for a concrete example.
}
\examples{

\dontrun{
library(parsnip)
library(rsample)
library(tune)
library(dials)
library(recipes)
# Grid search with tuning parameters in model
# No need to define the values of the tuning parameters
# as they have defaults. For example, see dials::penalty()
mod <-
  mtcars \%>\%
  tidyflow() \%>\%
  plug_split(initial_split) \%>\%
  plug_formula(mpg ~ .) \%>\% 
  plug_resample(vfold_cv) \%>\%
  plug_model(set_engine(linear_reg(penalty = tune(), mixture = tune()), "glmnet")) \%>\% 
  plug_grid(grid_regular)

res <- fit(mod)

res \%>\%
  pull_tflow_fit_tuning() \%>\%
  show_best("rsq")

# If you want to specify tuning values, you can do so with
# `plug_grid` or `replace_grid` but they must have the same
# name as the tuning parameter
res2 <-
  mod \%>\%
  replace_grid(grid_regular, penalty = penalty(c(-1, 0)), levels = 2) \%>\%
  fit()

res2 \%>\%
  pull_tflow_fit_tuning() \%>\%
  show_best("rsq")

# If tune assigns a name, then `plug_grid` or `replace_grid` must
# use that name to replace it
model <-
  set_engine(
    linear_reg(penalty = tune("my_penalty"), mixture = tune("my_mixture")),
    "glmnet"
  )

# You must use `my_penalty`
res3 <-
  mod \%>\%
  replace_model(model) \%>\%   
  replace_grid(grid_regular, my_penalty = penalty(c(-1, 0)), levels = 2) \%>\%
  fit()

res3 \%>\%
  pull_tflow_fit_tuning() \%>\%
  show_best("rsq")

# If you want to create all possible combination of grid values,
# you must use only `expand.grid` and `expand = TRUE`.
res4 <-
 mod \%>\%
 replace_grid(expand.grid,
              penalty = seq(0.01, 0.02, 0.005),
              mixture = c(0, 0.5, 1),
              expand = TRUE) \%>\%
 fit()

# See how they values are not random, but rather
# all combination of the supplied values
res4 \%>\%
 pull_tflow_fit_tuning() \%>\%
 collect_metrics()

# You can also tune values from a recipe directly
res5 <-
  res3 \%>\%
  drop_formula() \%>\% 
  plug_recipe(~ recipe(mpg ~ ., data = .) \%>\% step_ns(hp, deg_free = tune())) \%>\%
  fit()

res5 \%>\%
  pull_tflow_fit_tuning() \%>\%
  show_best("rsq")
}

}
