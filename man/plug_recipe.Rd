% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pre-action-recipe.R
\name{plug_recipe}
\alias{plug_recipe}
\alias{drop_recipe}
\alias{replace_recipe}
\title{Add a recipe to a tidyflow}
\usage{
plug_recipe(x, .f, ..., blueprint = NULL)

drop_recipe(x)

replace_recipe(x, .f, ..., blueprint = NULL)
}
\arguments{
\item{x}{A tidyflow}

\item{.f}{A function or a formula with a recipe inside. See the details
section.}

\item{...}{Not used.}

\item{blueprint}{A hardhat blueprint used for fine tuning the preprocessing.
If \code{NULL}, \code{\link[hardhat:default_recipe_blueprint]{hardhat::default_recipe_blueprint()}} is used.}
}
\value{
The tidyflow \code{x}, updated with either a new or removed recipe function.
}
\description{
\itemize{
\item \code{plug_recipe()} specifies the type of recipe used in the analysis. It
accepts a function \code{.f} that will be applied to the data. Only
functions which return a \code{recipe} object will be allowed. See
package \code{\link[recipes]{recipes}} for how to create a recipe.
\item \code{drop_recipe()} removes the recipe function from the tidyflow. Note
that it keeps other preprocessing steps such as the split and resample.
\item \code{replace_recipe()} first removes the recipe function, then adds the new
recipe function. Any model that has already been fit based on this
recipe will need to be refit.
}
}
\details{
To fit a tidyflow, one of \code{plug_formula()} or \code{plug_recipe()} \emph{must} be
specified, but not both.

\code{.f} can be either a function or a formula. In either case, both
things should have only one argument and return the recipe applied to
the only argument, which is assumed to be the data.

\itemize{
\item If a function is supplied, it is assumed that there is one argument
and that argument is for the data. The output should be the recipe
applied to the main argument. The \emph{function} is used as is.

\item If a \emph{formula}, e.g. \code{~ recipe(mpg ~ cyl, data = .)}, it is
converted to a function. It is also assumed that the first argument in the
recipe function is passed to the data. Other arguments will be ignored.
If a \emph{formula}, the argument name can be either \code{.} or \code{.x}. See the
examples section for more details.
}

Since the recipe step in a \code{tidyflow} is not the ideal step for
exploration, we suggest that the user constructs the recipe outside
the \code{tidyflow} and applies it to the data beforehand, just to make sure
it works. After making sure the recipe can be fitted without errors, the user
can provide the function or formula for the recipe. Defining a recipe without
testing on the data can lead to errors on \code{recipe} that are best fixed
in an interactive fashion.
}
\examples{
library(recipes)
library(parsnip)

# Passing a function to `plug_recipe`
recipe_fun <- function(.x) {
  recipe(mpg ~ ., data = .x) \%>\%
   step_center(all_predictors()) \%>\%
   step_scale(all_predictors())
}

# Let's make sure that it works with the data first
recipe_fun(mtcars)

# Specify the function to be applied to the data in `plug_recipe`
tflow <-
 mtcars \%>\%
 tidyflow() \%>\%
 plug_recipe(recipe_fun) \%>\%
 plug_model(set_engine(linear_reg(), "lm"))

# Fit the model
fit(tflow)

# Specify a formula of a recipe. Remove the old one and specify one on the
# fly:
tflow \%>\%
 replace_recipe(~ recipe(mpg ~ cyl, data = .) \%>\% step_log(cyl, base = 10)) \%>\%
 fit()

# Note how the function argument can be either `.` or `.x`
tflow \%>\%
 replace_recipe(~ {
  .x \%>\% 
   recipe(mpg ~ cyl + am) \%>\%
    step_log(cyl, base = 10) \%>\%
    step_mutate(am = factor(am)) \%>\%
    step_dummy(am)
 }) \%>\%
 fit()

}
