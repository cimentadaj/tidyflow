% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pre-action-grid.R
\name{plug_grid}
\alias{plug_grid}
\alias{drop_grid}
\alias{replace_grid}
\title{Add a split specification to a tidyflow}
\usage{
plug_grid(x, .f, ...)

drop_grid(x)

replace_grid(x, .f, ...)
}
\arguments{
\item{x}{A tidyflow}

\item{.f}{A function which will be passed the tuned arguments from the model
and recipe. Must return an object of class \code{param_grid}. See package
\code{\link[dials]{dials}}.}

\item{...}{arguments passed to \code{.f}. The processing of \code{...}
respects the quotation rules from \code{.f}. In other words, if the function
allows variables as strings \strong{and} as names, the user can specify both.
See the example sections.}
}
\value{
\code{x}, updated with either a new or removed grid specification.
}
\description{
\itemize{
\item \code{plug_grid()} specifies the type of grid used in the model tuning. It
accepts a function \code{.f} that will be fed the tuning parameters defined
in the model and the recipe. Only functions which return a \code{param_grid}
object will be allowed. See package \code{\link[dials]{dials}} and
the details section. If a model has been fit before adding the grid,
it will need to be refit.
\item \code{drop_grid()} removes the grid specification from the tidyflow. Note
that it keeps other preprocessing steps such as the recipe and model.
\item \code{replace_grid()} first removes the grid, then adds a new grid
specification. Any model that has already been fit based on this
split will need to be refit.
}
}
\details{
The grid specification is an optional step in the tidyflow. You can add a
dataframe, prepare a recipe and fit the model without adding a grid
specification.

The tuning parameters defined in the model and recipe are extracted
and passed to \code{.f}. This should return an object of class
\code{param_grid}. These functions come from the \code{\link[dials]{dials}}
package.

If a tuning parameter in the model/recipe is assigned a name (that is,
\code{tune("new_name")}) and the user is interested in specifying
the tuning values for that parameter using \code{plug_grid} or
\code{replace_grid}, then the parameter name should have the name not
the original name. See the example section for a concrete example.
}
\examples{

\dontrun{
library(parsnip)
library(rsample)
library(tune)
library(dials)
library(recipes)
# Grid search with tuning parameters in model
# No need to define the values of the tuning parameters
# as they have defaults. For example, see dials::penalty()
mod <-
  mtcars \%>\%
  tidyflow() \%>\%
  plug_split(initial_split) \%>\%
  plug_formula(mpg ~ .) \%>\% 
  plug_resample(vfold_cv) \%>\%
  plug_model(set_engine(linear_reg(penalty = tune(), mixture = tune()), "glmnet")) \%>\% 
  plug_grid(grid_regular)

res <- fit(mod)

res \%>\%
  pull_tflow_fit_tuning() \%>\%
  show_best("rsq")

# If you want to specify tuning values, you can do so with
# `plug_grid` or `replace_grid` but they must have the same
# name as the tuning parameter
res2 <-
  mod \%>\%
  replace_grid(grid_regular, penalty = penalty(c(-1, 0)), levels = 2) \%>\%
  fit()

res2 \%>\%
  pull_tflow_fit_tuning() \%>\%
  show_best("rsq")

# If tune assigns a name, then `plug_grid` or `replace_grid` must
# use that name to replace it
model <-
  set_engine(
    linear_reg(penalty = tune("my_penalty"), mixture = tune("my_mixture")),
    "glmnet"
  )

# You must use `my_penalty`
res3 <-
  mod \%>\%
  replace_model(model) \%>\%   
  replace_grid(grid_regular, my_penalty = penalty(c(-1, 0)), levels = 2) \%>\%
  fit()

res3 \%>\%
  pull_tflow_fit_tuning() \%>\%
  show_best("rsq")

# Finally, you can also tune values from a recipe directly
res4 <-
  res3 \%>\%
  drop_formula() \%>\% 
  plug_recipe(~ recipe(mpg ~ ., data = .) \%>\% step_ns(hp, deg_free = tune())) \%>\%
  fit()

res4 \%>\%
  pull_tflow_fit_tuning() \%>\%
  show_best("rsq")
}

}
