
R version 4.0.2 (2020-06-22) -- "Taking Off Again"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "tidyflow"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "tidyflow-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('tidyflow')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("complete_tflow")
> ### * complete_tflow
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: complete_tflow
> ### Title: Fit the best model from a tuning grid
> ### Aliases: complete_tflow
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(parsnip)
> ##D library(tune)
> ##D library(dials)
> ##D library(rsample)
> ##D 
> ##D # Fit a regularized regression through a grid search.
> ##D reg_mod <- set_engine(linear_reg(penalty = tune(), mixture = tune()), "glmnet")
> ##D tuned_res <-
> ##D  mtcars %>%
> ##D   tidyflow() %>% 
> ##D   plug_resample(vfold_cv, v = 2) %>% 
> ##D   plug_formula(mpg ~ .) %>% 
> ##D   plug_model(reg_mod) %>%
> ##D   plug_grid(grid_regular, levels = 1) %>%
> ##D   fit()
> ##D 
> ##D # Finalize the best model and refit on the whole dataset
> ##D final_model <- complete_tflow(tuned_res, metric = "rmse")
> ##D 
> ##D # complete_tflow uses tune::select_best as the default method. However,
> ##D # tune::select_by_one_std_err and
> ##D # tune::select_by_pct_loss can be used. These need to specify the metric and
> ##D # the tuning value from which to sort the selection. For example:
> ##D final_model_stderr <- complete_tflow(tuned_res,
> ##D                                      metric = "rmse",
> ##D                                      method = "select_by_one_std_err",
> ##D                                      penalty)
> ##D 
> ##D # select_by_one_std_err finalizs the best model with the simplest tuning
> ##D # values within one standard deviation from most optimal
> ##D # combination. For more information on these methods, see
> ##D # ?select_best
> ##D 
> ##D # You can also specify the best parameters, in case you want
> ##D # to override the automatic extraction of the best fit. If you
> ##D # specify `best_params` it will override all other arguments
> ##D 
> ##D best_params <- select_best(pull_tflow_fit_tuning(tuned_res), metric = "rmse")
> ##D final_model_custom <- complete_tflow(tuned_res, best_params = best_params)
> ##D 
> ##D # To see the final tuning values, extract the model spec
> ##D pull_tflow_spec(final_model)
> ##D 
> ##D # To extract the final fitted model:
> ##D pull_tflow_fit(final_model)
> ##D 
> ##D # Since there was no `plug_split`, the final model is fitted
> ##D # entirely on the data (no training/testing). If you try to predict
> ##D # on either one, it will not work:
> ##D final_model %>%
> ##D   predict_training()
> ##D 
> ##D # Add a split step, fit again and then finalize the model
> ##D # to predict on the training set
> ##D tuned_split <-
> ##D   tuned_res %>%
> ##D   replace_grid(grid_regular) %>% 
> ##D   plug_split(initial_split) %>%
> ##D   fit()
> ##D 
> ##D tuned_split %>%
> ##D  complete_tflow(metric = "rmse") %>%
> ##D  predict_training()
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("complete_tflow", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("control_tidyflow")
> ### * control_tidyflow
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: control_tidyflow
> ### Title: Control object for a tidyflow
> ### Aliases: control_tidyflow
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(parsnip)
> ##D library(rsample)
> ##D library(tune)
> ##D library(tidyflow)
> ##D 
> ##D # Build tidyflow
> ##D tflow <-
> ##D   mtcars %>%
> ##D   tidyflow() %>%
> ##D   plug_split(initial_split) %>%
> ##D   plug_formula(mpg ~ .) %>%
> ##D   plug_resample(vfold_cv, v = 2) %>% 
> ##D   plug_model(set_engine(linear_reg(), "lm"))
> ##D 
> ##D # For each resample object, we want the predictions
> ##D ct <- control_tidyflow(control_resample = control_resamples(save_pred = TRUE,
> ##D                                                             verbose = TRUE))
> ##D 
> ##D # Specify the control object
> ##D fit_m <- fit(tflow, control = ct)
> ##D fit_m
> ##D 
> ##D # Extract the predictions
> ##D fit_m %>%
> ##D   pull_tflow_fit_tuning() %>%
> ##D   .[[".predictions"]]
> ##D 
> ##D # `control_resamples` is only used when there is a resample but not
> ##D # grid. When there is a resample and a grid, `control_grid` should be
> ##D # used.
> ##D ct <- control_tidyflow(control_grid = control_grid(verbose = TRUE,
> ##D                                                    save_pred = TRUE))
> ##D 
> ##D # Since there is no grid specification, this is ignored.
> ##D # No messages should be printed nor a new .predictions
> ##D # columns in the result
> ##D fit_m <- fit(tflow, control = ct)
> ##D fit_m
> ##D 
> ##D # control_parsnip controls the options of the model
> ##D # For example, verbosity controls the messags of the model
> ##D ct <- control_tidyflow(control_parsnip = control_parsnip(verbosity = 2))
> ##D 
> ##D # Run a regularized regression with only one independent variable.
> ##D # This is not possible, it will raise an error and we will see it
> ##D # because of verbosity
> ##D res <-
> ##D   tflow %>%
> ##D   replace_model(set_engine(linear_reg(penalty = 0, mixture = 1), "glmnet")) %>%
> ##D   replace_formula(mpg ~ cyl) %>% 
> ##D   fit(control = ct)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("control_tidyflow", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fit-tidyflow")
> ### * fit-tidyflow
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fit-tidyflow
> ### Title: Fit a tidyflow object
> ### Aliases: fit-tidyflow fit.tidyflow
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(parsnip)
> ##D library(recipes)
> ##D library(tune)
> ##D library(dials)
> ##D library(rsample)
> ##D 
> ##D # Fit a simple linear model
> ##D model <- set_engine(linear_reg(), "lm")
> ##D 
> ##D formula_tidyflow <-
> ##D  mtcars %>%
> ##D  tidyflow() %>%
> ##D  plug_formula(mpg ~ cyl + log(disp)) %>%
> ##D  plug_model(model)
> ##D 
> ##D # The result is a model since we didn't specify any resample/grid
> ##D res <- fit(formula_tidyflow)
> ##D 
> ##D # You can extract the model fit if neede
> ##D res %>%
> ##D  pull_tflow_fit()
> ##D 
> ##D # Alternatively, we can add a split specification and
> ##D # predict on the training data automatically:
> ##D formula_tidyflow <-
> ##D  formula_tidyflow %>%
> ##D  plug_split(initial_split)
> ##D 
> ##D res2 <- fit(formula_tidyflow)
> ##D 
> ##D res2 %>%
> ##D  predict_training()
> ##D 
> ##D # This has the advantage that `predict_training` or `predict_testing` will
> ##D # apply the recipe/formula automatically for you:
> ##D 
> ##D recipe_tidyflow <-
> ##D  formula_tidyflow %>%
> ##D  drop_formula() %>% 
> ##D  plug_recipe(~ recipe(mpg ~ ., .x) %>% step_log(disp))
> ##D 
> ##D res3 <- fit(recipe_tidyflow)
> ##D res3 %>%
> ##D  predict_testing()
> ##D 
> ##D # We can accumulate steps and add a cross-validation and tuning grid.
> ##D # Fit a regularized regression through a grid search.
> ##D # Do this by updating the already defined model:
> ##D new_mod <- set_engine(linear_reg(penalty = tune(), mixture = tune()),
> ##D                       "glmnet")
> ##D tuned_res <-
> ##D   recipe_tidyflow %>%
> ##D   plug_resample(vfold_cv, v = 2) %>% 
> ##D   replace_model(new_mod) %>%
> ##D   plug_grid(grid_regular, levels = 2) %>%
> ##D   fit()
> ##D 
> ##D # Since we specified a resample/grid, the result is now a `tidyflow`
> ##D # with a resample object
> ##D tuned_res
> ##D 
> ##D # If needed, we can extract that resample:
> ##D tuned_res %>%
> ##D  pull_tflow_fit_tuning() %>%
> ##D  autoplot()
> ##D 
> ##D # When the model tuning is finished, `complete_tflow` can
> ##D # finalize the model with the best model. It can pick
> ##D # the best model for you.
> ##D 
> ##D tuned_res %>%
> ##D  complete_tflow(metric = "rmse") %>%
> ##D  predict_training()
> ##D 
> ##D # `complete_tflow` is powerful as it already applied the recipe
> ##D # and retrained the model on the entire training data with
> ##D # the best tuning parameter from the tuning grid.
> ##D 
> ##D # The power of this model building is that you can replace any step
> ##D # and rerun the fit:
> ##D bootstrap_res <-
> ##D  tuned_res %>%
> ##D  replace_resample(bootstraps, times = 2) %>%
> ##D  fit()
> ##D 
> ##D bootstrap_res %>%
> ##D  complete_tflow(metric = "rsq") %>%
> ##D  predict_training()
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fit-tidyflow", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("parameters-tidyflow")
> ### * parameters-tidyflow
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: parameters-tidyflow
> ### Title: Extract the parameters of a tidyflow
> ### Aliases: parameters-tidyflow parameters
> 
> ### ** Examples
> 
> library(rsample)
> library(tune)

Attaching package: ‘tune’

The following object is masked from ‘package:tidyflow’:

    parameters

> library(dials)
Loading required package: scales

Attaching package: ‘dials’

The following object is masked from ‘package:tidyflow’:

    parameters

> library(recipes)
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


Attaching package: ‘recipes’

The following object is masked from ‘package:stats’:

    step

> library(parsnip)
> 
> tflow <-
+   mtcars %>%
+   tidyflow() %>%
+   plug_split(initial_split) %>%
+   plug_formula(mpg ~ .) %>% 
+   plug_resample(vfold_cv) %>%
+   plug_grid(grid_regular) %>%
+   plug_model(set_engine(linear_reg(), "lm"))
> 
> # No tuning parameters
> tidyflow::parameters(tflow)
Collection of 0 parameters for tuning

[1] id             parameter type object class  
<0 rows> (or 0-length row.names)

> 
> # But if we add tuning parameters, we can check which ones:
> tflow %>%
+   drop_formula() %>% 
+   plug_recipe(~ recipe(mpg ~ ., data = .) %>% step_ns(hp, deg_free = tune())) %>%
+   tidyflow::parameters()
Collection of 1 parameters for tuning

       id parameter type object class
 deg_free       deg_free    nparam[+]

> 
> # parameters extracts both the tuning parameters from the recipe and
> # model:
> tflow <-
+   tflow %>%
+   drop_formula() %>% 
+   plug_recipe(~ recipe(mpg ~ ., data = .) %>% step_ns(hp, deg_free = tune())) %>%
+   replace_model(set_engine(linear_reg(penalty = tune(), mixture = tune()), "glmnet"))
> 
> tidyflow::parameters(tflow)
Collection of 3 parameters for tuning

       id parameter type object class
  penalty        penalty    nparam[+]
  mixture        mixture    nparam[+]
 deg_free       deg_free    nparam[+]

> 
> # This can serve well to refresh your memory on which tuning
> # parameters are present and then override the custom values
> # in `plug_grid`:
> ## Not run: 
> ##D   res <-
> ##D     tflow %>%
> ##D     replace_grid(grid_regular, penalty = penalty(c(-1, 0))) %>%
> ##D     fit()
> ##D   res
> ## End(Not run)
> 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("parameters-tidyflow", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:parsnip’, ‘package:recipes’, ‘package:dplyr’,
  ‘package:dials’, ‘package:scales’, ‘package:tune’, ‘package:rsample’

> nameEx("plug_data")
> ### * plug_data
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plug_data
> ### Title: Add a data to a tidyflow
> ### Aliases: plug_data drop_data replace_data
> 
> ### ** Examples
> 
> 
> wf <- tidyflow()
> wf <- plug_data(wf, mtcars)
> wf
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe/Formula: None
Resample: None
Grid: None
Model: None
> 
> drop_data(wf)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: None
Split: None
Recipe/Formula: None
Resample: None
Grid: None
Model: None
> 
> replace_data(wf, iris)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 150 rows x 5 columns
Split: None
Recipe/Formula: None
Resample: None
Grid: None
Model: None
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plug_data", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plug_formula")
> ### * plug_formula
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plug_formula
> ### Title: Add formula terms to a tidyflow
> ### Aliases: plug_formula drop_formula replace_formula
> 
> ### ** Examples
> 
> 
> # Just for the pipe: %>%
> library(tibble)
> 
> tflow <-
+   mtcars %>%
+   tidyflow(seed = 652341) %>% 
+   plug_formula(mpg ~ .)
> 
> tflow
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Formula: mpg ~ .
Resample: None
Grid: None
Model: None
> 
> drop_formula(tflow)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe/Formula: None
Resample: None
Grid: None
Model: None
> 
> replace_formula(tflow, mpg ~ disp)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Formula: mpg ~ disp
Resample: None
Grid: None
Model: None
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plug_formula", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:tibble’

> nameEx("plug_grid")
> ### * plug_grid
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plug_grid
> ### Title: Add a grid specification to a tidyflow
> ### Aliases: plug_grid drop_grid replace_grid
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D library(parsnip)
> ##D library(rsample)
> ##D library(tune)
> ##D library(dials)
> ##D library(recipes)
> ##D 
> ##D # Grid search:
> ##D # No need to define the values of the tuning parameters
> ##D # as they have defaults. For example, see the output of dials::penalty()
> ##D 
> ##D # `plug_grid` defines the grid. You can pass all of the arguments of
> ##D # `grid_regular`:
> ##D mod <-
> ##D   mtcars %>%
> ##D   tidyflow() %>%
> ##D   plug_split(initial_split) %>%
> ##D   plug_formula(mpg ~ .) %>% 
> ##D   plug_resample(vfold_cv) %>%
> ##D   plug_model(set_engine(linear_reg(penalty = tune(), mixture = tune()), "glmnet")) %>%
> ##D   plug_grid(grid_regular, levels = 5)
> ##D 
> ##D res <- fit(mod)
> ##D 
> ##D # See the grid that was generated after the fit:
> ##D res %>%
> ##D   pull_tflow_grid()
> ##D 
> ##D # The argument `levels = 5` tells it to generate 5 x 5 combination
> ##D # of all possible vaues. That's why you have 25 rows.
> ##D 
> ##D # You can extract the result from `plug_grid` with `pull_tflow_fit_tuning`:
> ##D pull_tflow_fit_tuning(res)
> ##D 
> ##D # Visualize it:
> ##D pull_tflow_fit_tuning(res) %>%
> ##D  autoplot()
> ##D 
> ##D # And explore it:
> ##D 
> ##D pull_tflow_fit_tuning(res) %>%
> ##D  collect_metrics()
> ##D 
> ##D # If you want to specify tuning values, you can do so with
> ##D # `plug_grid` or `replace_grid` but they must have the same
> ##D # name as the tuning parameter
> ##D res2 <-
> ##D   mod %>%
> ##D   replace_grid(grid_regular, penalty = penalty(c(-1, 0)), levels = 2) %>%
> ##D   fit()
> ##D 
> ##D res2 %>%
> ##D   pull_tflow_fit_tuning() %>%
> ##D   show_best("rsq")
> ##D 
> ##D # If tune assigns a name, then `plug_grid` or `replace_grid` must
> ##D # use that name to replace it
> ##D model <-
> ##D   set_engine(
> ##D     linear_reg(penalty = tune("my_penalty"), mixture = tune("my_mixture")),
> ##D     "glmnet"
> ##D   )
> ##D 
> ##D # You must use `my_penalty`
> ##D res3 <-
> ##D   mod %>%
> ##D   replace_model(model) %>%   
> ##D   replace_grid(grid_regular, my_penalty = penalty(c(-1, 0)), levels = 2) %>%
> ##D   fit()
> ##D 
> ##D res3 %>%
> ##D   pull_tflow_fit_tuning() %>%
> ##D   show_best("rsq")
> ##D 
> ##D # If you want to create a grid of all possible combination of the tuning
> ##D # parameters, you must use only `expand.grid` and name every single
> ##D # model parameter:
> ##D res4 <-
> ##D  mod %>%
> ##D  replace_grid(expand.grid,
> ##D               penalty = seq(0.01, 0.02, 0.005),
> ##D               mixture = c(0, 0.5, 1)) %>%
> ##D  fit()
> ##D 
> ##D # The resulting grid is all of the possible combinations
> ##D # from the values defined above:
> ##D res4 %>%
> ##D  pull_tflow_grid()
> ##D 
> ##D # See how they values are not random, but rather
> ##D # all combination of the supplied values
> ##D res4 %>%
> ##D  pull_tflow_fit_tuning() %>%
> ##D  collect_metrics()
> ##D 
> ##D # You can also tune values from a recipe directly
> ##D res5 <-
> ##D   res3 %>%
> ##D   drop_formula() %>% 
> ##D   plug_recipe(~ recipe(mpg ~ ., data = .) %>% step_ns(hp, deg_free = tune())) %>%
> ##D   fit()
> ##D 
> ##D res5 %>%
> ##D   pull_tflow_fit_tuning() %>%
> ##D   show_best("rsq")
> ## End(Not run)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plug_grid", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plug_model")
> ### * plug_model
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plug_model
> ### Title: Add a model to a tidyflow
> ### Aliases: plug_model drop_model replace_model
> 
> ### ** Examples
> 
> library(parsnip)
> 
> # Define two competing model:
> lm_model <- set_engine(linear_reg(), "lm")
> regularized_model <- set_engine(lm_model, "glmnet")
> 
> # Define a minimal tidyflow: data + formula + model
> wf <-
+   mtcars %>%
+   tidyflow() %>%
+   plug_formula(mpg ~ .) %>% 
+   plug_model(lm_model)
> 
> wf
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Formula: mpg ~ .
Resample: None
Grid: None
Model:
Linear Regression Model Specification (regression)

Computational engine: lm 

> 
> # We can drop the model at any time and the remaining steps
> # are intact
> drop_model(wf)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Formula: mpg ~ .
Resample: None
Grid: None
Model: None
> 
> # We can fit the model with `fit`:
> fitted <- fit(wf)
> 
> # Extract the model if needed:
> fitted %>%
+   pull_tflow_fit()
parsnip model object

Fit time:  2ms 

Call:
stats::lm(formula = formula, data = data)

Coefficients:
(Intercept)          cyl         disp           hp         drat           wt  
   12.30337     -0.11144      0.01334     -0.02148      0.78711     -3.71530  
       qsec           vs           am         gear         carb  
    0.82104      0.31776      2.52023      0.65541     -0.19942  

> 
> # If we remove the model from the fitted `tidyflow`,
> # the fit is dropped:
> drop_model(fitted)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Formula: mpg ~ .
Resample: None
Grid: None
Model: None
> 
> # We could replace the model from the initial tidyflow with
> # the regularized model with `replace_model`
> 
> ## TODO: when https://github.com/cimentadaj/tidyflow/issues/4 is fixed
> ## replace wf with fitted here.
> 
> reg_fitted <-
+   wf %>%
+   replace_model(regularized_model) %>%
+   fit()
> 
> reg_fitted %>%
+   pull_tflow_fit()
parsnip model object

Fit time:  8ms 

Call:  glmnet::glmnet(x = as.matrix(x), y = y, family = "gaussian") 

   Df   %Dev Lambda
1   0 0.0000 5.1470
2   2 0.1290 4.6900
3   2 0.2481 4.2730
4   2 0.3469 3.8940
5   2 0.4290 3.5480
6   2 0.4971 3.2320
7   2 0.5537 2.9450
8   2 0.6006 2.6840
9   2 0.6396 2.4450
10  3 0.6726 2.2280
11  3 0.7015 2.0300
12  3 0.7256 1.8500
13  3 0.7455 1.6850
14  3 0.7621 1.5360
15  3 0.7759 1.3990
16  3 0.7873 1.2750
17  3 0.7968 1.1620
18  3 0.8046 1.0580
19  3 0.8112 0.9645
20  3 0.8166 0.8788
21  3 0.8211 0.8007
22  3 0.8249 0.7296
23  4 0.8281 0.6648
24  5 0.8320 0.6057
25  5 0.8360 0.5519
26  6 0.8396 0.5029
27  6 0.8426 0.4582
28  6 0.8451 0.4175
29  6 0.8472 0.3804
30  8 0.8489 0.3466
31  8 0.8514 0.3158
32  8 0.8535 0.2878
33  8 0.8553 0.2622
34  8 0.8568 0.2389
35  8 0.8580 0.2177
36  8 0.8590 0.1983
37  8 0.8598 0.1807
38  9 0.8606 0.1647
39  9 0.8615 0.1500
40  9 0.8622 0.1367
41  9 0.8627 0.1246
42  9 0.8632 0.1135
43  9 0.8636 0.1034
44  9 0.8639 0.0942
45  9 0.8642 0.0859
46  9 0.8644 0.0782
47  9 0.8646 0.0713
48  9 0.8648 0.0649
49  9 0.8649 0.0592
50  9 0.8650 0.0539
51  9 0.8651 0.0491
52  9 0.8652 0.0448
53  9 0.8652 0.0408
54 10 0.8654 0.0372
55 10 0.8660 0.0339
56 10 0.8665 0.0309
57 10 0.8669 0.0281
58 10 0.8673 0.0256
59 10 0.8676 0.0233
60 10 0.8678 0.0213
61 10 0.8680 0.0194
62 10 0.8682 0.0177
63 10 0.8683 0.0161
64 10 0.8684 0.0147
65 10 0.8685 0.0134
66 10 0.8686 0.0122
67 10 0.8687 0.0111
68 10 0.8687 0.0101
69 10 0.8688 0.0092
70 10 0.8688 0.0084
71 10 0.8688 0.0076
72 10 0.8689 0.0070
73 10 0.8689 0.0063
74 10 0.8689 0.0058
75 10 0.8689 0.0053
76 10 0.8689 0.0048
77 10 0.8689 0.0044
78 10 0.8690 0.0040
79 10 0.8690 0.0036
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plug_model", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:parsnip’

> nameEx("plug_recipe")
> ### * plug_recipe
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plug_recipe
> ### Title: Add a recipe to a tidyflow
> ### Aliases: plug_recipe drop_recipe replace_recipe
> 
> ### ** Examples
> 
> library(recipes)
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


Attaching package: ‘recipes’

The following object is masked from ‘package:stats’:

    step

> library(parsnip)
> 
> # Passing a function to `plug_recipe`
> recipe_fun <- function(.x) {
+   recipe(mpg ~ ., data = .x) %>%
+    step_center(all_predictors()) %>%
+    step_scale(all_predictors())
+ }
> 
> # Let's make sure that it works with the data first
> recipe_fun(mtcars)
Data Recipe

Inputs:

      role #variables
   outcome          1
 predictor         10

Operations:

Centering for all_predictors
Scaling for all_predictors
> 
> # Specify the function to be applied to the data in `plug_recipe`
> tflow <-
+  mtcars %>%
+  tidyflow() %>%
+  plug_recipe(recipe_fun) %>%
+  plug_model(set_engine(linear_reg(), "lm"))
> 
> # Fit the model
> fit(tflow)
══ Tidyflow [trained] ══════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe: available
Resample: None
Grid: None
Model:
Linear Regression Model Specification (regression)

Computational engine: lm 

══ Results ═════════════════════════════════════════════════════════════════════


Fitted model:

Call:
stats::lm(formula = formula, data = data)

Coefficients:

...
and 5 more lines.
> 
> # Specify a formula of a recipe. Remove the old one and specify one on the
> # fly:
> tflow %>%
+  replace_recipe(~ recipe(mpg ~ cyl, data = .) %>% step_log(cyl, base = 10)) %>%
+  fit()
══ Tidyflow [trained] ══════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe: available
Resample: None
Grid: None
Model:
Linear Regression Model Specification (regression)

Computational engine: lm 

══ Results ═════════════════════════════════════════════════════════════════════


Fitted model:

Call:
stats::lm(formula = formula, data = data)

Coefficients:

...
and 3 more lines.
> 
> # Note how the function argument can be either `.` or `.x`
> tflow %>%
+  replace_recipe(~ {
+   .x %>% 
+    recipe(mpg ~ cyl + am) %>%
+     step_log(cyl, base = 10) %>%
+     step_mutate(am = factor(am)) %>%
+     step_dummy(am)
+  }) %>%
+  fit()
══ Tidyflow [trained] ══════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe: available
Resample: None
Grid: None
Model:
Linear Regression Model Specification (regression)

Computational engine: lm 

══ Results ═════════════════════════════════════════════════════════════════════


Fitted model:

Call:
stats::lm(formula = formula, data = data)

Coefficients:

...
and 3 more lines.
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plug_recipe", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:parsnip’, ‘package:recipes’, ‘package:dplyr’

> nameEx("plug_resample")
> ### * plug_resample
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plug_resample
> ### Title: Add a resample specification to a tidyflow
> ### Aliases: plug_resample drop_resample replace_resample
> 
> ### ** Examples
> 
> library(tibble)
> library(rsample)
> 
> wf <-
+  mtcars %>%
+  tidyflow() %>%
+  plug_resample(vfold_cv, v = 5, strata = "cyl")
> 
> wf
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe/Formula: None
Resample: vfold_cv w/ v = ~5, strata = ~"cyl"
Grid: None
Model: None
> 
> # Strata as unquoted name
> wf <- replace_resample(wf, initial_split, v = 5, strata = cyl)
> 
> wf
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe/Formula: None
Resample: initial_split w/ v = ~5, strata = ~cyl
Grid: None
Model: None
> 
> drop_resample(wf)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe/Formula: None
Resample: None
Grid: None
Model: None
> 
> # New split function
> replace_resample(wf, bootstraps)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe/Formula: None
Resample: bootstraps w/ default args
Grid: None
Model: None
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plug_resample", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rsample’, ‘package:tibble’

> nameEx("plug_split")
> ### * plug_split
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plug_split
> ### Title: Add a split specification to a tidyflow
> ### Aliases: plug_split drop_split replace_split
> 
> ### ** Examples
> 
> library(tibble)
> library(rsample)
> 
> wf <-
+  mtcars %>%
+  tidyflow() %>%
+  plug_split(initial_split, prop = 0.8, strata = "cyl")
> 
> wf
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: initial_split w/ prop = ~0.8, strata = ~"cyl"
Recipe/Formula: None
Resample: None
Grid: None
Model: None
> 
> # Strata as unquoted name
> wf <- replace_split(wf, initial_split, prop = 0.8, strata = cyl)
> 
> wf
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: initial_split w/ prop = ~0.8, strata = ~cyl
Recipe/Formula: None
Resample: None
Grid: None
Model: None
> 
> drop_split(wf)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe/Formula: None
Resample: None
Grid: None
Model: None
> 
> # New split function
> replace_split(wf, initial_time_split)
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: initial_time_split w/ default args
Recipe/Formula: None
Resample: None
Grid: None
Model: None
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plug_split", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rsample’, ‘package:tibble’

> nameEx("predict-tidyflow")
> ### * predict-tidyflow
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: predict-tidyflow
> ### Title: Predict from a tidyflow
> ### Aliases: predict-tidyflow predict.tidyflow predict_training
> ###   predict_testing
> 
> ### ** Examples
> 
> ## Not run: 
> ##D library(parsnip)
> ##D library(recipes)
> ##D library(rsample)
> ##D library(dials)
> ##D library(tune)
> ##D 
> ##D model <- set_engine(linear_reg(), "lm")
> ##D 
> ##D tflow <-
> ##D  mtcars %>%
> ##D  tidyflow() %>%
> ##D  plug_split(initial_split) %>%
> ##D  plug_model(model) %>%
> ##D  plug_recipe(~ recipe(mpg ~ cyl + disp, .) %>% step_log(disp))
> ##D 
> ##D tflow <- fit(tflow)
> ##D 
> ##D # This will automatically `bake()` the recipe on `new_data`,
> ##D # applying the log step to `disp`, and then fit the regression.
> ##D predict(tflow, new_data = pull_tflow_testing(tflow))
> ##D 
> ##D # When a split has been specified through `plug_split`,
> ##D # predict_training/predict_testing automatically extract
> ##D # everything and applies the recip/formula:
> ##D predict_testing(tflow)
> ##D predict_training(tflow)
> ##D 
> ##D # When a grid search has been performed, the user needs to
> ##D # finalize the model through complete_tflow and then
> ##D # predict/predict_training/predict_testing will work.
> ##D res <-
> ##D  tflow %>%
> ##D  # Adds a grid search for the polynomials of qsec
> ##D  replace_recipe(~ recipe(mpg ~ ., data = .) %>% step_ns(hp, deg_free = tune())) %>%
> ##D  plug_resample(vfold_cv, v = 2) %>% 
> ##D  plug_grid(grid_regular, levels = 1) %>%
> ##D  fit()
> ##D 
> ##D # We can complete the tidyflow by fitting the best model
> ##D # based on the RMSE metric and then predict:
> ##D res %>%
> ##D  complete_tflow(metric = "rmse") %>%
> ##D  predict_training()
> ##D 
> ##D # In short, to be able to predict, you need to have either a single model
> ##D # or a finalized tuning grid with `complete_tflow`.
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("predict-tidyflow", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("tidyflow-extractors")
> ### * tidyflow-extractors
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tidyflow-extractors
> ### Title: Extract elements of a tidyflow
> ### Aliases: tidyflow-extractors pull_tflow_rawdata pull_tflow_split
> ###   pull_tflow_training pull_tflow_testing pull_tflow_resample
> ###   pull_tflow_grid pull_tflow_preprocessor pull_tflow_prepped_recipe
> ###   pull_tflow_mold pull_tflow_spec pull_tflow_fit pull_tflow_fit_tuning
> 
> ### ** Examples
> 
> library(parsnip)
> library(recipes)
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


Attaching package: ‘recipes’

The following object is masked from ‘package:stats’:

    step

> library(rsample)
> 
> model <- set_engine(linear_reg(), "lm")
> 
> recipe <- ~ recipe(.x, mpg ~ cyl + disp) %>% step_log(disp)
> 
> tflow <-
+  mtcars %>%
+  tidyflow() %>%
+  plug_split(initial_split) %>%
+  plug_model(model)
> 
> recipe_tflow <- plug_recipe(tflow, recipe)
> formula_tflow <- plug_formula(tflow, mpg ~ cyl + log(disp))
> 
> fit_recipe_tflow <- fit(recipe_tflow)
> fit_formula_tflow <- fit(formula_tflow)
> 
> pull_tflow_rawdata(fit_recipe_tflow)
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> pull_tflow_rawdata(fit_formula_tflow)
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> 
> # The preprocessor is either the recipe function or a formula
> pull_tflow_preprocessor(recipe_tflow)
<lambda>
function (..., .x = ..1, .y = ..2, . = ..1) 
recipe(.x, mpg ~ cyl + disp) %>% step_log(disp)
attr(,"class")
[1] "rlang_lambda_function" "function"             
> pull_tflow_preprocessor(formula_tflow)
mpg ~ cyl + log(disp)
> 
> # The `spec` is the parsnip spec before it has been fit.
> # The `fit` is the fit parsnip model.
> pull_tflow_spec(fit_formula_tflow)
Linear Regression Model Specification (regression)

Computational engine: lm 

> pull_tflow_fit(fit_formula_tflow)
parsnip model object

Fit time:  0ms 

Call:
stats::lm(formula = formula, data = data)

Coefficients:
(Intercept)          cyl  `log(disp)`  
    62.4676      -0.4948      -7.4628  

> 
> # The mold is returned from `hardhat::mold()`, and contains the
> # predictors, outcomes, and information about the preprocessing
> # for use on new data at `predict()` time.
> pull_tflow_mold(fit_recipe_tflow)
$predictors
# A tibble: 24 x 2
     cyl  disp
   <dbl> <dbl>
 1     6  5.08
 2     6  5.08
 3     4  4.68
 4     8  5.89
 5     6  5.42
 6     4  4.99
 7     4  4.95
 8     6  5.12
 9     8  5.62
10     8  5.62
# … with 14 more rows

$outcomes
# A tibble: 24 x 1
     mpg
   <dbl>
 1  21  
 2  21  
 3  22.8
 4  18.7
 5  18.1
 6  24.4
 7  22.8
 8  19.2
 9  16.4
10  17.3
# … with 14 more rows

$blueprint
Recipe blueprint: 
 
# Predictors: 2 
  # Outcomes: 1 
   Intercept: FALSE 
Novel Levels: FALSE 

$extras
$extras$roles
NULL


> 
> # The raw training and testing
> pull_tflow_training(fit_recipe_tflow)
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> pull_tflow_testing(fit_recipe_tflow)
                mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Duster 360     14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora  15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
> 
> # Or with the preprocessor (recipe/formula) applied
> pull_tflow_training(fit_recipe_tflow, prep = TRUE)
    mpg cyl     disp
1  21.0   6 5.075174
2  21.0   6 5.075174
3  22.8   4 4.682131
4  18.7   8 5.886104
5  18.1   6 5.416100
6  24.4   4 4.988390
7  22.8   4 4.947340
8  19.2   6 5.121580
9  16.4   8 5.619676
10 17.3   8 5.619676
11 15.2   8 5.619676
12 10.4   8 6.156979
13 10.4   8 6.131226
14 14.7   8 6.086775
15 32.4   4 4.365643
16 33.9   4 4.264087
17 15.5   8 5.762051
18 15.2   8 5.717028
19 13.3   8 5.857933
20 19.2   8 5.991465
21 26.0   4 4.789989
22 30.4   4 4.554929
23 15.8   8 5.860786
24 21.4   4 4.795791
> pull_tflow_testing(fit_recipe_tflow, prep = TRUE)
   mpg cyl     disp
1 21.4   6 5.552960
2 14.3   8 5.886104
3 17.8   6 5.121580
4 30.4   4 4.326778
5 21.5   4 4.788325
6 27.3   4 4.369448
7 19.7   6 4.976734
8 15.0   8 5.707110
> 
> # A useful shortcut is to extract the prepped recipe from the tidyflow
> pull_tflow_prepped_recipe(fit_recipe_tflow)
Data Recipe

Inputs:

      role #variables
   outcome          1
 predictor          2

Training data contained 24 data points and no missing data.

Operations:

Log transformation on disp [trained]
> 
> # That is identical to
> identical(
+   pull_tflow_mold(fit_recipe_tflow)$blueprint$recipe,
+   pull_tflow_prepped_recipe(fit_recipe_tflow)
+ )
[1] TRUE
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tidyflow-extractors", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:rsample’, ‘package:recipes’, ‘package:dplyr’,
  ‘package:parsnip’

> nameEx("tidyflow")
> ### * tidyflow
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: tidyflow
> ### Title: Create a tidyflow
> ### Aliases: tidyflow
> 
> ### ** Examples
> 
> library(recipes)
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union


Attaching package: ‘recipes’

The following object is masked from ‘package:stats’:

    step

> library(rsample)
> library(dials)
Loading required package: scales

Attaching package: ‘dials’

The following object is masked from ‘package:tidyflow’:

    parameters

> library(parsnip)
> library(tune)

Attaching package: ‘tune’

The following object is masked from ‘package:tidyflow’:

    parameters

> 
> wflow <-
+  mtcars %>%
+  tidyflow(seed = 23113) %>%
+  plug_recipe(~ recipe(mpg ~ cyl, .x) %>% step_log(cyl))
> 
> # tidyflow gives a prinout of the current specification
> # in the order of execution:
> wflow
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe: available
Resample: None
Grid: None
Model: None
> 
> # The minimum tidyflow is: data + recipe/formula + model
> wflow <-
+  wflow %>%
+  plug_model(set_engine(linear_reg(), "lm"))
> 
> # The output shows that we have the data, the recipe and the model
> wflow
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe: available
Resample: None
Grid: None
Model:
Linear Regression Model Specification (regression)

Computational engine: lm 

> 
> # We can fit that model and we get a brief print out of the model:
> fit(wflow)
══ Tidyflow [trained] ══════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: None
Recipe: available
Resample: None
Grid: None
Model:
Linear Regression Model Specification (regression)

Computational engine: lm 

══ Results ═════════════════════════════════════════════════════════════════════


Fitted model:

Call:
stats::lm(formula = formula, data = data)

Coefficients:

...
and 3 more lines.
> 
> # We can add further steps and the print out will tell you the
> # workflow specification:
> wflow <-
+  wflow %>%
+  plug_split(initial_split) %>%
+  plug_resample(vfold_cv, v = 2) %>%
+  plug_grid(grid_regular)
> 
> # The print out shows that we have a split/resample/grid
> # now set correcly.
> wflow
══ Tidyflow ════════════════════════════════════════════════════════════════════
Data: 32 rows x 11 columns
Split: initial_split w/ default args
Recipe: available
Resample: vfold_cv w/ v = ~2
Grid: grid_regular w/ default args
Model:
Linear Regression Model Specification (regression)

Computational engine: lm 

> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("tidyflow", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:tune’, ‘package:parsnip’, ‘package:dials’,
  ‘package:scales’, ‘package:rsample’, ‘package:recipes’,
  ‘package:dplyr’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  4.918 0.072 4.996 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
