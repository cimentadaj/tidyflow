% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/complete_tflow.R
\name{complete_tflow}
\alias{complete_tflow}
\title{Fit the best model from a tuning grid}
\usage{
complete_tflow(
  x,
  metric,
  ...,
  best_params = NULL,
  method = c("select_best", "select_by_one_std_err", "select_by_pct_loss"),
  control = control_tidyflow()
)
}
\arguments{
\item{x}{A tidyflow}

\item{metric}{The metric of reference from which to pick the best model}

\item{...}{Extra arguments passed to
\code{\link[tune]{select_by_one_std_err}} or
\code{\link[tune]{select_by_pct_loss}}}

\item{best_params}{A 1 row tibble with the best parameters to fit the final
model. Should have the same format as the result of
\code{\link[tune]{select_best}},
\code{\link[tune]{select_by_one_std_err}} or
\code{\link[tune]{select_by_pct_loss}}. If \code{best_params} is specified,
the \code{method}, \code{metric} and \code{...} arguments are ignored.}

\item{method}{which method to use. The possible values are
\code{\link[tune]{select_best}}, \code{\link[tune]{select_by_one_std_err}} or
\code{\link[tune]{select_by_pct_loss}}. By default, it uses
\code{\link[tune]{select_best}}.}

\item{control}{A \code{\link{control_tidyflow}} object. The
\code{\link[parsnip]{control_parsnip}} control object inside
\code{\link{control_tidyflow}} is passed to
\code{\link[parsnip]{fit}} or \code{\link[parsnip]{fit}}.}
}
\value{
The tidyflow \code{object} updated with the fitted best model. Can be
extracted with \code{\link{pull_tflow_fit}} and used to predict on the
training or test data with \code{\link{predict_training}} or
\code{\link{predict_testing}}
}
\description{
Fit the best model from a tuning grid
}
\details{
The finalized model is fitted on the training data if
\code{plug_split} was specified otherwise on the complete data.
}
\examples{
library(parsnip)
library(tune)
library(dials)
library(rsample)

# Fit a regularized regression through a grid search.
reg_mod <- set_engine(linear_reg(penalty = tune(), mixture = tune()), "glmnet")
tuned_res <-
 mtcars \%>\%
  tidyflow() \%>\% 
  plug_resample(vfold_cv, v = 2) \%>\% 
  plug_formula(mpg ~ .) \%>\% 
  plug_model(reg_mod) \%>\%
  plug_grid(grid_regular, levels = 1) \%>\%
  fit()

# Finalize the best model and refit on the whole dataset
final_model <- complete_tflow(tuned_res, metric = "rmse")

# complete_tflow uses tune::select_best as the default method. However,
# tune::select_by_one_std_err and
# tune::select_by_pct_loss can be used. These need to specify the metric and
# the tuning value from which to sort the selection. For example:
final_model_stderr <- complete_tflow(tuned_res,
                                     metric = "rmse",
                                     method = "select_by_one_std_err",
                                     penalty)

# select_by_one_std_err finalizs the best model with the simplest tuning
# values within one standard deviation from most optimal
# combination. For more information on these methods, see
# ?select_best

# You can also specify the best parameters, in case you want
# to override the automatic extraction of the best fit. If you
# specify `best_params` it will override all other arguments

best_params <- select_best(pull_tflow_fit_tuning(tuned_res), metric = "rmse")
final_model_custom <- complete_tflow(tuned_res, best_params = best_params)

# To see the final tuning values, extract the model spec
pull_tflow_spec(final_model)

# To extract the final fitted model:
pull_tflow_fit(final_model)

# Since there was no `plug_split`, the final model is fitted
# entirely on the data (no training/testing). If you try to predict
# on either one, it will not work:
\dontrun{
final_model \%>\%
  predict_training()

# Add a split step, fit again and then finalize the model
# to predict on the training set
tuned_split <-
  tuned_res \%>\%
  replace_grid(grid_regular) \%>\% 
  plug_split(initial_split) \%>\%
  fit()

tuned_split \%>\%
 complete_tflow(metric = "rmse") \%>\%
 predict_training()
}

}
